package openapi

import (
	"fmt"
	"go/ast"
	"go/token"
	"log/slog"
	"strconv"
	"strings"
	"sync"
)

// SchemaGenerator handles dynamic schema generation from Go types
// If a TypeIndex is provided, it will be used for fast lookup.
type SchemaGenerator struct {
	schemas   map[string]*Schema
	typeIndex *TypeIndex
	mutex     sync.Mutex
}

// NewSchemaGenerator creates a new schema generator. Optionally accepts a TypeIndex.
func NewSchemaGenerator(opts ...*TypeIndex) *SchemaGenerator {
	slog.Debug("[openapi] NewSchemaGenerator: initializing", "opts_len", len(opts))
	var idx *TypeIndex
	if len(opts) > 0 && opts[0] != nil {
		idx = opts[0]
	} else {
		// Use global typeIndex if no specific index provided
		ensureTypeIndex() // Ensure typeIndex is initialized
		idx = typeIndex
	}

	return &SchemaGenerator{
		schemas:   make(map[string]*Schema),
		typeIndex: idx,
	}
}

// GenerateSchema creates a JSON schema for the given type name.
// All types are stored using qualified names (e.g., "order.CreateReq", "sqlc.User").
func (sg *SchemaGenerator) GenerateSchema(typeName string) *Schema {
	slog.Debug("[openapi] GenerateSchema: called", "typeName", typeName)

	// 1) Fast-path simple/empty types
	if typeName == "" || typeName == "<autogenerated>" {
		slog.Debug("[openapi] GenerateSchema: empty typeName, returning object schema")
		return &Schema{Type: "object"}
	}

	// 2) For basic types, return directly without caching
	if isBasicType(typeName) {
		return sg.generateBasicTypeSchema(typeName)
	}

	// 3) Normalize the type name to use qualified names
	qualifiedName := sg.getQualifiedTypeName(typeName)
	slog.Debug("[openapi] GenerateSchema: type name conversion", "typeName", typeName, "qualifiedName", qualifiedName)

	// 4) Check external known types first
	if sg.typeIndex != nil {
		if schema, ok := sg.typeIndex.externalKnownTypes[qualifiedName]; ok {
			slog.Debug("[openapi] GenerateSchema: using externalKnownTypes", "qualifiedName", qualifiedName)
			return schema
		}
	}

	// 5) Check if schema already exists (avoid duplicate work)
	sg.mutex.Lock()
	if existingSchema, exists := sg.schemas[qualifiedName]; exists {
		sg.mutex.Unlock()
		if existingSchema == nil {
			// Currently being processed, return reference
			return &Schema{Ref: fmt.Sprintf("#/components/schemas/%s", qualifiedName)}
		}
		slog.Debug("[openapi] GenerateSchema: schema already exists", "qualifiedName", qualifiedName)
		return &Schema{Ref: fmt.Sprintf("#/components/schemas/%s", qualifiedName)}
	}

	// 6) Reserve placeholder to prevent infinite recursion
	sg.schemas[qualifiedName] = nil
	sg.mutex.Unlock()

	// 7) Check if it's an enum type
	if enumSchema := sg.handleEnumType(qualifiedName); enumSchema != nil {
		slog.Debug("[openapi] GenerateSchema: detected enum type", "qualifiedName", qualifiedName)
		sg.mutex.Lock()
		sg.schemas[qualifiedName] = enumSchema
		sg.mutex.Unlock()
		return &Schema{Ref: fmt.Sprintf("#/components/schemas/%s", qualifiedName)}
	}

	// 8) Generate the actual schema
	var built *Schema
	if sg.typeIndex != nil {
		// Try qualified lookup first
		if ts := sg.typeIndex.LookupQualifiedType(qualifiedName); ts != nil {
			if structType, ok := ts.Type.(*ast.StructType); ok {
				slog.Debug("[openapi] GenerateSchema: found struct in TypeIndex", "qualifiedName", qualifiedName)
				built = sg.convertStructToSchema(structType)
			}
		}
	}

	// 9) Fallback for unknown types
	if built == nil {
		slog.Debug(
			"[openapi] GenerateSchema: TypeIndex lookup failed, using basic mapping",
			"qualifiedName",
			qualifiedName,
		)
		basicType := mapGoTypeToOpenAPI(qualifiedName)
		built = &Schema{
			Type:        basicType,
			Description: "external or unknown type",
		}
	}

	// 10) Store the built schema
	sg.mutex.Lock()
	slog.Debug("[openapi] GenerateSchema: storing schema", "qualifiedName", qualifiedName, "originalTypeName", typeName)
	sg.schemas[qualifiedName] = built
	if sg.typeIndex != nil && sg.typeIndex.externalKnownTypes != nil {
		sg.typeIndex.externalKnownTypes[qualifiedName] = &Schema{
			Ref: fmt.Sprintf("#/components/schemas/%s", qualifiedName),
		}
	}
	sg.mutex.Unlock()

	// 11) Always return a reference
	return &Schema{Ref: fmt.Sprintf("#/components/schemas/%s", qualifiedName)}
}

// GetSchemas returns all generated schemas
func (sg *SchemaGenerator) GetSchemas() map[string]Schema {
	slog.Debug("[openapi] GetSchemas: returning all generated schemas", "count", len(sg.schemas))
	result := make(map[string]Schema)
	for name, schema := range sg.schemas {
		result[name] = *schema
	}
	return result
}

// convertStructToSchema converts an AST struct to OpenAPI schema
func (sg *SchemaGenerator) convertStructToSchema(structType *ast.StructType) *Schema {
	slog.Debug("[openapi] convertStructToSchema: called")
	schema := &Schema{
		Type:       "object",
		Properties: make(map[string]*Schema),
		Required:   []string{},
	}

	for _, field := range structType.Fields.List {
		if len(field.Names) == 0 {
			continue // embedded field
		}

		fieldName := field.Names[0].Name
		if !ast.IsExported(fieldName) {
			continue // skip unexported fields
		}

		// Extract JSON tag
		jsonName := fieldName
		if field.Tag != nil {
			tag := strings.Trim(field.Tag.Value, "`")
			if jsonTag := extractJSONTag(tag); jsonTag != "" && jsonTag != "-" {
				jsonName = jsonTag
			}
		}

		// Convert field type to schema
		fieldSchema := sg.convertFieldType(field.Type)

		// Apply OpenAPI 3.1 enhancements from struct tags
		if field.Tag != nil {
			tag := strings.Trim(field.Tag.Value, "`")
			sg.applyEnhancedTags(fieldSchema, tag)
		}

		schema.Properties[jsonName] = fieldSchema

		// Ensure referenced types are generated using qualified names
		switch t := field.Type.(type) {
		case *ast.Ident:
			if t.Obj != nil && t.Obj.Kind == ast.Typ {
				// Generate schema for the type using qualified name
				qualifiedTypeName := sg.getQualifiedTypeName(t.Name)
				_ = sg.GenerateSchema(qualifiedTypeName)
			}
		case *ast.StarExpr:
			if ident, ok := t.X.(*ast.Ident); ok {
				if ident.Obj != nil && ident.Obj.Kind == ast.Typ {
					// Generate schema for the type using qualified name
					qualifiedTypeName := sg.getQualifiedTypeName(ident.Name)
					_ = sg.GenerateSchema(qualifiedTypeName)
				}
			}
		case *ast.SelectorExpr:
			if ident, ok := t.X.(*ast.Ident); ok {
				qualifiedName := ident.Name + "." + t.Sel.Name
				_ = sg.GenerateSchema(qualifiedName)
			}
		}

		// Check if required (simple heuristic: no pointer, no omitempty)
		if !isPointerType(field.Type) && !hasOmitEmpty(field.Tag) {
			schema.Required = append(schema.Required, jsonName)
		}
	}

	return schema
}

// convertFieldType converts an AST type to OpenAPI schema
func (sg *SchemaGenerator) convertFieldType(expr ast.Expr) *Schema {
	slog.Debug("[openapi] convertFieldType: called")

	switch t := expr.(type) {
	case *ast.Ident:
		slog.Debug("[openapi] convertFieldType: Ident type", "name", t.Name)
		// Check if it's a basic type first
		basicType := mapGoTypeToOpenAPI(t.Name)
		if basicType != "object" {
			schema := &Schema{Type: basicType}
			sg.enhanceSchemaBasedOnGoType(schema, t.Name)
			return schema
		}
		// For custom types, generate schema using qualified name
		qualifiedTypeName := sg.getQualifiedTypeName(t.Name)
		return sg.GenerateSchema(qualifiedTypeName)

	case *ast.StarExpr:
		slog.Debug("[openapi] convertFieldType: StarExpr (pointer) type")
		baseSchema := sg.convertFieldType(t.X)
		// For pointer types, we could enhance with nullable support in OpenAPI 3.1
		return baseSchema

	case *ast.ArrayType:
		slog.Debug("[openapi] convertFieldType: ArrayType")
		elemSchema := sg.convertFieldType(t.Elt)
		return &Schema{
			Type:  "array",
			Items: elemSchema,
		}

	case *ast.SelectorExpr:
		slog.Debug("[openapi] convertFieldType: SelectorExpr", "sel", t.Sel.Name)
		// Handle qualified types like json.RawMessage, time.Time, etc.
		if ident, ok := t.X.(*ast.Ident); ok {
			qualifiedName := ident.Name + "." + t.Sel.Name
			slog.Debug("[openapi] convertFieldType: generating schema for qualified type", "qualifiedName", qualifiedName)
			return sg.GenerateSchema(qualifiedName)
		}

	case *ast.MapType:
		slog.Debug("[openapi] convertFieldType: MapType")
		return &Schema{
			Type:                 "object",
			AdditionalProperties: sg.convertFieldType(t.Value),
		}

	case *ast.InterfaceType:
		slog.Debug("[openapi] convertFieldType: InterfaceType")
		return &Schema{Type: "object"}
	}

	slog.Debug("[openapi] convertFieldType: unknown type, defaulting to object")
	return &Schema{Type: "object"}
}

// applyEnhancedTags applies OpenAPI 3.1 metadata from struct tags to a schema
func (sg *SchemaGenerator) applyEnhancedTags(schema *Schema, tag string) {
	// Parse openapi tag for enhanced features
	if openapiTag := sg.extractTag(tag, "openapi"); openapiTag != "" {
		parts := strings.Split(openapiTag, ",")
		for _, part := range parts {
			part = strings.TrimSpace(part)
			if strings.Contains(part, "=") {
				kv := strings.SplitN(part, "=", 2)
				key, value := strings.TrimSpace(kv[0]), strings.TrimSpace(kv[1])

				switch key {
				case "format":
					schema.Format = value
				case "pattern":
					schema.Pattern = value
				case "example":
					schema.Example = value
				case "title":
					schema.Title = value
				case "deprecated":
					if value == "true" {
						deprecated := true
						schema.Deprecated = &deprecated
					}
				case "readOnly":
					if value == "true" {
						readOnly := true
						schema.ReadOnly = &readOnly
					}
				case "writeOnly":
					if value == "true" {
						writeOnly := true
						schema.WriteOnly = &writeOnly
					}
				case "minimum":
					if min, err := strconv.ParseFloat(value, 64); err == nil {
						schema.Minimum = &min
					}
				case "maximum":
					if max, err := strconv.ParseFloat(value, 64); err == nil {
						schema.Maximum = &max
					}
				case "minLength":
					if minLen, err := strconv.Atoi(value); err == nil {
						schema.MinLength = &minLen
					}
				case "maxLength":
					if maxLen, err := strconv.Atoi(value); err == nil {
						schema.MaxLength = &maxLen
					}
				case "minItems":
					if minItems, err := strconv.Atoi(value); err == nil {
						schema.MinItems = &minItems
					}
				case "maxItems":
					if maxItems, err := strconv.Atoi(value); err == nil {
						schema.MaxItems = &maxItems
					}
				case "uniqueItems":
					if value == "true" {
						uniqueItems := true
						schema.UniqueItems = &uniqueItems
					}
				case "enum":
					// Parse pipe-separated enum values
					enumValues := strings.Split(value, "|")
					schema.Enum = make([]interface{}, len(enumValues))
					for i, v := range enumValues {
						schema.Enum[i] = strings.TrimSpace(v)
					}
				case "default":
					schema.Default = value
				}
			}
		}
	}

	// Parse validate tag for additional constraints
	if validateTag := sg.extractTag(tag, "validate"); validateTag != "" {
		// Support common validation tags
		if strings.Contains(validateTag, "email") {
			schema.Format = "email"
		}
		if strings.Contains(validateTag, "uuid") {
			schema.Format = "uuid"
		}
		if strings.Contains(validateTag, "uri") {
			schema.Format = "uri"
		}
		if strings.Contains(validateTag, "url") {
			schema.Format = "uri"
		}
	}

	// Parse binding tag for additional format hints
	if bindingTag := sg.extractTag(tag, "binding"); bindingTag != "" {
		if strings.Contains(bindingTag, "email") {
			schema.Format = "email"
		}
		if strings.Contains(bindingTag, "uuid") {
			schema.Format = "uuid"
		}
	}
}

// extractTag extracts a specific tag value from a struct tag string
func (sg *SchemaGenerator) extractTag(tag, key string) string {
	for _, part := range strings.Split(tag, " ") {
		if strings.HasPrefix(part, key+":") {
			value := strings.Trim(part[len(key)+1:], "\"")
			return value
		}
	}
	return ""
}

// getQualifiedTypeName returns the qualified type name for schema keys.
// This ensures consistent naming across the schema generation process.
func (sg *SchemaGenerator) getQualifiedTypeName(typeName string) string {
	// If already qualified, return as-is
	if strings.Contains(typeName, ".") {
		slog.Debug("[openapi] getQualifiedTypeName: already qualified", "typeName", typeName)
		return typeName
	}

	// Use TypeIndex to get the proper qualified name
	if sg.typeIndex != nil {
		qualifiedName := sg.typeIndex.GetQualifiedTypeName(typeName)
		slog.Debug("[openapi] getQualifiedTypeName: converted", "typeName", typeName, "qualifiedName", qualifiedName)
		return qualifiedName
	}

	// Fallback to original name
	slog.Debug("[openapi] getQualifiedTypeName: no typeIndex, using original", "typeName", typeName)
	return typeName
}

// Helper functions
func extractJSONTag(tag string) string {
	for _, part := range strings.Split(tag, " ") {
		if strings.HasPrefix(part, "json:") {
			value := strings.Trim(part[5:], "\"")
			if comma := strings.Index(value, ","); comma != -1 {
				return value[:comma]
			}
			return value
		}
	}
	return ""
}

func isPointerType(expr ast.Expr) bool {
	_, ok := expr.(*ast.StarExpr)
	return ok
}

func hasOmitEmpty(tag *ast.BasicLit) bool {
	if tag == nil {
		return false
	}
	return strings.Contains(tag.Value, "omitempty")
}

// isBasicType returns true if the given type name represents a basic Go type
func isBasicType(typeName string) bool {
	switch typeName {
	case "int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64",
		"float32", "float64",
		"string", "bool",
		"byte", "rune":
		return true
	default:
		// Array types are also considered basic for OpenAPI purposes
		if strings.HasPrefix(typeName, "[]") {
			return true
		}
		// Pointer types to basic types
		if strings.HasPrefix(typeName, "*") && isBasicType(strings.TrimPrefix(typeName, "*")) {
			return true
		}
		// Map types
		if strings.HasPrefix(typeName, "map[") {
			return true
		}
		return false
	}
}

// generateBasicTypeSchema creates a schema for basic Go types without caching
func (sg *SchemaGenerator) generateBasicTypeSchema(typeName string) *Schema {
	if strings.HasPrefix(typeName, "[]") {
		// Array type - extract element type
		elementType := strings.TrimPrefix(typeName, "[]")
		elementSchema := sg.GenerateSchema(elementType)
		return &Schema{
			Type:  "array",
			Items: elementSchema,
		}
	}
	if strings.HasPrefix(typeName, "*") {
		// Pointer type - return the underlying type
		underlyingType := strings.TrimPrefix(typeName, "*")
		return sg.GenerateSchema(underlyingType)
	}
	if strings.HasPrefix(typeName, "map[") {
		// Map type - return object schema
		return &Schema{
			Type:                 "object",
			AdditionalProperties: true,
		}
	}

	// Basic primitive types
	basicType := mapGoTypeToOpenAPI(typeName)
	return &Schema{
		Type:        basicType,
		Description: "basic Go type",
	}
}

// enhanceSchemaBasedOnGoType enhances a schema based on Go type information
func (sg *SchemaGenerator) enhanceSchemaBasedOnGoType(schema *Schema, goType string) {
	// Add format hints for common Go types
	switch goType {
	case "time.Time", "*time.Time":
		schema.Format = "date-time"
	case "uuid.UUID", "*uuid.UUID":
		schema.Format = "uuid"
	case "url.URL", "*url.URL":
		schema.Format = "uri"
	case "net.IP":
		schema.Format = "ipv4"
	case "json.RawMessage":
		// For json.RawMessage, allow any JSON structure
		schema.Type = "object"
		schema.Description = "Raw JSON data"
		schema.AdditionalProperties = true
	}

	// Handle slice and array types
	if strings.HasPrefix(goType, "[]") {
		elementType := strings.TrimPrefix(goType, "[]")
		if elementType == "string" {
			// For string arrays, add some sensible defaults
			uniqueItems := true
			schema.UniqueItems = &uniqueItems
		}
	}

	// Handle pointer types by removing nullability constraints if applicable
	if strings.HasPrefix(goType, "*") {
		// Pointer types are typically nullable, but OpenAPI 3.1 handles this differently
		// In OpenAPI 3.1, we can use oneOf with null type for nullable fields
		if schema.Type != "" && schema.Type != "object" {
			// Create a oneOf schema with the original type and null
			originalSchema := &Schema{
				Type:        schema.Type,
				Format:      schema.Format,
				Pattern:     schema.Pattern,
				Minimum:     schema.Minimum,
				Maximum:     schema.Maximum,
				MinLength:   schema.MinLength,
				MaxLength:   schema.MaxLength,
				Enum:        schema.Enum,
				Example:     schema.Example,
				Description: schema.Description,
			}

			// Clear the original schema and set up oneOf
			schema.Type = ""
			schema.Format = ""
			schema.Pattern = ""
			schema.Minimum = nil
			schema.Maximum = nil
			schema.MinLength = nil
			schema.MaxLength = nil
			schema.Enum = nil
			schema.Example = nil

			schema.OneOf = []*Schema{
				originalSchema,
				{Type: "null"},
			}
		}
	}
}

// handleEnumType detects and handles enum types using qualified names
func (sg *SchemaGenerator) handleEnumType(qualifiedName string) *Schema {
	slog.Debug("[openapi] handleEnumType: checking if type is enum", "qualifiedName", qualifiedName)

	if sg.typeIndex == nil {
		return nil
	}

	// Look up the type specification using qualified name
	ts := sg.typeIndex.LookupQualifiedType(qualifiedName)
	if ts == nil {
		return nil
	}

	// Check if it's a string-based type alias (common pattern for enums)
	if ident, ok := ts.Type.(*ast.Ident); ok && ident.Name == "string" {
		slog.Debug("[openapi] handleEnumType: found string-based type", "qualifiedName", qualifiedName)

		// Extract package name for enum value lookup
		parts := strings.Split(qualifiedName, ".")
		if len(parts) != 2 {
			return nil
		}

		packageName, typeName := parts[0], parts[1]
		enumValues := sg.extractEnumValues(packageName, typeName)

		if len(enumValues) > 0 {
			slog.Debug(
				"[openapi] handleEnumType: found enum values",
				"qualifiedName",
				qualifiedName,
				"count",
				len(enumValues),
			)
			return &Schema{
				Type:        "string",
				Enum:        enumValues,
				Description: fmt.Sprintf("Enum type %s", qualifiedName),
			}
		}
	}

	return nil
}

// Add this new function to extract enum values from constants
func (sg *SchemaGenerator) extractEnumValues(packageName, typeName string) []interface{} {
	slog.Debug("[openapi] extractEnumValues: extracting enum values", "package", packageName, "type", typeName)

	if sg.typeIndex == nil {
		return nil
	}

	var enumValues []interface{}

	// Look through all files in the package for constants of this type
	for filePath, file := range sg.typeIndex.files {
		// Check if this file belongs to the package we're interested in
		if file.Name.Name != packageName {
			continue
		}

		slog.Debug("[openapi] extractEnumValues: checking file", "file", filePath)

		// Walk through all declarations in the file
		for _, decl := range file.Decls {
			if genDecl, ok := decl.(*ast.GenDecl); ok && genDecl.Tok == token.CONST {
				// This is a const declaration
				for _, spec := range genDecl.Specs {
					if valueSpec, ok := spec.(*ast.ValueSpec); ok {
						// Check if this constant is of our target type
						if sg.isConstantOfType(valueSpec, typeName) {
							// Extract the string value
							for i, name := range valueSpec.Names {
								if i < len(valueSpec.Values) {
									if value := sg.extractStringLiteral(valueSpec.Values[i]); value != "" {
										slog.Debug(
											"[openapi] extractEnumValues: found enum value",
											"name",
											name.Name,
											"value",
											value,
										)
										enumValues = append(enumValues, value)
									}
								}
							}
						}
					}
				}
			}
		}
	}

	return enumValues
}

// Helper function to check if a constant is of a specific type
func (sg *SchemaGenerator) isConstantOfType(valueSpec *ast.ValueSpec, typeName string) bool {
	if valueSpec.Type == nil {
		return false
	}

	// Check if the type matches
	if ident, ok := valueSpec.Type.(*ast.Ident); ok {
		return ident.Name == typeName
	}

	return false
}

// Helper function to extract string literal value
func (sg *SchemaGenerator) extractStringLiteral(expr ast.Expr) string {
	if basicLit, ok := expr.(*ast.BasicLit); ok && basicLit.Kind == token.STRING {
		// Remove quotes from string literal
		value := basicLit.Value
		if len(value) >= 2 && value[0] == '"' && value[len(value)-1] == '"' {
			return value[1 : len(value)-1]
		}
	}
	return ""
}
