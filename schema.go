package openapi

import (
	"fmt"
	"go/ast"
	"log/slog"
	"strings"
	"sync"
)

// SchemaGenerator handles dynamic schema generation from Go types
// If a TypeIndex is provided, it will be used for fast lookup.
type SchemaGenerator struct {
	schemas   map[string]*Schema
	typeIndex *TypeIndex
	mutex     sync.Mutex
}

// NewSchemaGenerator creates a new schema generator. Optionally accepts a TypeIndex.
func NewSchemaGenerator(opts ...*TypeIndex) *SchemaGenerator {
	slog.Debug("[openapi] NewSchemaGenerator: initializing", "opts_len", len(opts))
	var idx *TypeIndex
	if len(opts) > 0 && opts[0] != nil {
		idx = opts[0]
	} else {
		// Use global typeIndex if no specific index provided
		ensureTypeIndex() // Ensure typeIndex is initialized
		idx = typeIndex
	}

	return &SchemaGenerator{
		schemas:   make(map[string]*Schema),
		typeIndex: idx,
	}
}

// GenerateSchema creates a JSON schema for the given type name.
// All types are stored using qualified names (e.g., "order.CreateReq", "sqlc.User").
func (sg *SchemaGenerator) GenerateSchema(typeName string) *Schema {
	slog.Debug("[openapi] GenerateSchema: called", "typeName", typeName)

	// 1) Fast-path simple/empty types
	if typeName == "" || typeName == "<autogenerated>" {
		slog.Debug("[openapi] GenerateSchema: empty typeName, returning object schema")
		return &Schema{Type: "object"}
	}

	// 2) For basic types, return directly without caching
	if isBasicType(typeName) {
		return sg.generateBasicTypeSchema(typeName)
	}

	// 3) Normalize the type name to use qualified names
	qualifiedName := sg.getQualifiedTypeName(typeName)
	slog.Debug("[openapi] GenerateSchema: type name conversion", "typeName", typeName, "qualifiedName", qualifiedName)

	// 4) Check external known types first
	if sg.typeIndex != nil {
		if schema, ok := sg.typeIndex.externalKnownTypes[qualifiedName]; ok {
			slog.Debug("[openapi] GenerateSchema: using externalKnownTypes", "qualifiedName", qualifiedName)
			return schema
		}
	}

	// 5) Check if schema already exists (avoid duplicate work)
	sg.mutex.Lock()
	if existingSchema, exists := sg.schemas[qualifiedName]; exists {
		sg.mutex.Unlock()
		if existingSchema == nil {
			// Currently being processed, return reference
			return &Schema{Ref: fmt.Sprintf("#/components/schemas/%s", qualifiedName)}
		}
		slog.Debug("[openapi] GenerateSchema: schema already exists", "qualifiedName", qualifiedName)
		return &Schema{Ref: fmt.Sprintf("#/components/schemas/%s", qualifiedName)}
	}

	// 6) Reserve placeholder to prevent infinite recursion
	sg.schemas[qualifiedName] = nil
	sg.mutex.Unlock()

	// 7) Check if it's an enum type
	if enumSchema := sg.handleEnumType(qualifiedName); enumSchema != nil {
		slog.Debug("[openapi] GenerateSchema: detected enum type", "qualifiedName", qualifiedName)
		sg.mutex.Lock()
		sg.schemas[qualifiedName] = enumSchema
		sg.mutex.Unlock()
		return &Schema{Ref: fmt.Sprintf("#/components/schemas/%s", qualifiedName)}
	}

	// 8) Generate the actual schema
	var built *Schema
	if sg.typeIndex != nil {
		// Try qualified lookup first
		if ts := sg.typeIndex.LookupQualifiedType(qualifiedName); ts != nil {
			if structType, ok := ts.Type.(*ast.StructType); ok {
				slog.Debug("[openapi] GenerateSchema: found struct in TypeIndex", "qualifiedName", qualifiedName)
				built = sg.convertStructToSchema(structType)
			}
		}
	}

	// 9) Fallback for unknown types
	if built == nil {
		slog.Debug(
			"[openapi] GenerateSchema: TypeIndex lookup failed, using basic mapping",
			"qualifiedName",
			qualifiedName,
		)
		basicType := mapGoTypeToOpenAPI(qualifiedName)
		built = &Schema{
			Type:        basicType,
			Description: "external or unknown type",
		}
	}

	// 10) Store the built schema
	sg.mutex.Lock()
	slog.Debug("[openapi] GenerateSchema: storing schema", "qualifiedName", qualifiedName, "originalTypeName", typeName)
	sg.schemas[qualifiedName] = built
	if sg.typeIndex != nil && sg.typeIndex.externalKnownTypes != nil {
		sg.typeIndex.externalKnownTypes[qualifiedName] = &Schema{
			Ref: fmt.Sprintf("#/components/schemas/%s", qualifiedName),
		}
	}
	sg.mutex.Unlock()

	// 11) Always return a reference
	return &Schema{Ref: fmt.Sprintf("#/components/schemas/%s", qualifiedName)}
}

// getQualifiedTypeName returns the qualified type name for schema keys.
// It uses the TypeIndex if available, otherwise falls back to the original name.
func (sg *SchemaGenerator) getQualifiedTypeName(typeName string) string {
	// Already qualified
	if strings.Contains(typeName, ".") {
		slog.Debug("[openapi] getQualifiedTypeName: already qualified", "typeName", typeName)
		return typeName
	}
	if sg.typeIndex != nil {
		qualified := sg.typeIndex.GetQualifiedTypeName(typeName)
		slog.Debug("[openapi] getQualifiedTypeName: converted", "typeName", typeName, "qualifiedName", qualified)
		return qualified
	}
	slog.Debug("[openapi] getQualifiedTypeName: no typeIndex, using original", "typeName", typeName)
	return typeName
}

// GetSchemas returns all generated schemas.
func (sg *SchemaGenerator) GetSchemas() map[string]Schema {
	slog.Debug("[openapi] GetSchemas: returning all generated schemas", "count", len(sg.schemas))
	result := make(map[string]Schema, len(sg.schemas))
	for name, schema := range sg.schemas {
		result[name] = *schema
	}
	return result
}
