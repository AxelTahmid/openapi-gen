package openapi

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log/slog"
	"os"
	"path/filepath"
	"strings"
	"sync"
)

// SchemaGenerator handles dynamic schema generation from Go types
// If a TypeIndex is provided, it will be used for fast lookup.
type SchemaGenerator struct {
	schemas   map[string]*Schema
	typeIndex *TypeIndex
	mutex     sync.Mutex
}

// NewSchemaGenerator creates a new schema generator. Optionally accepts a TypeIndex.
func NewSchemaGenerator(opts ...*TypeIndex) *SchemaGenerator {
	slog.Debug("[openapi] NewSchemaGenerator: initializing", "opts_len", len(opts))
	var idx *TypeIndex
	if len(opts) > 0 && opts[0] != nil {
		idx = opts[0]
	} else {
		// Use global typeIndex if no specific index provided
		idx = typeIndex
	}

	return &SchemaGenerator{
		schemas:   make(map[string]*Schema),
		typeIndex: idx,
	}
}

// GenerateSchema creates a JSON schema for the given type name
func (sg *SchemaGenerator) GenerateSchema(typeName string) *Schema {
	slog.Debug("[openapi] GenerateSchema: called", "typeName", typeName)

	// 1) Fast-path simple/empty types
	if typeName == "" || typeName == "<autogenerated>" {
		slog.Debug("[openapi] GenerateSchema: empty typeName, returning object schema")
		return &Schema{Type: "object"}
	}

	// 2) External known types (no locking needed)
	if sg.typeIndex != nil {
		if schema, ok := sg.typeIndex.externalKnownTypes[typeName]; ok {
			slog.Debug("[openapi] GenerateSchema: using externalKnownTypes", "typeName", typeName)
			return schema
		}
	}

	// For basic types, don't use caching - return directly
	if isBasicType(typeName) {
		return sg.generateBasicTypeSchema(typeName)
	}

	// 3) Reserve placeholder under lock
	sg.mutex.Lock()
	if _, exists := sg.schemas[typeName]; exists {
		sg.mutex.Unlock()
		slog.Debug("[openapi] GenerateSchema: schema already exists", "typeName", typeName)
		return &Schema{Ref: fmt.Sprintf("#/components/schemas/%s", typeName)}
	}
	sg.schemas[typeName] = nil
	sg.mutex.Unlock()

	// 4) Do the real work *without* holding the lock
	var built *Schema

	// 4a) Try TypeIndex first
	if sg.typeIndex != nil {
		parts := strings.Split(typeName, ".")
		if len(parts) == 2 {
			// Qualified type (e.g., "sqlc.RoleType")
			pkg, typ := parts[0], parts[1]
			if ts := sg.typeIndex.LookupType(pkg, typ); ts != nil {
				if structType, ok := ts.Type.(*ast.StructType); ok {
					slog.Debug("[openapi] GenerateSchema: found qualified struct in TypeIndex", "typeName", typeName)
					built = sg.convertStructToSchema(structType)
				}
			}
		} else {
			// Unqualified type - use efficient lookup
			if ts, pkg := sg.typeIndex.LookupUnqualifiedType(typeName); ts != nil {
				if structType, ok := ts.Type.(*ast.StructType); ok {
					slog.Debug("[openapi] GenerateSchema: found unqualified struct in TypeIndex", "typeName", typeName, "package", pkg)
					built = sg.convertStructToSchema(structType)
				}
			}
		}
	}

	// 4b) Fast fallback: basic type mapping (no expensive file parsing)
	if built == nil {
		slog.Debug("[openapi] GenerateSchema: TypeIndex lookup failed, using basic type mapping", "typeName", typeName)
		basicType := mapGoTypeToOpenAPI(typeName)
		built = &Schema{
			Type:        basicType,
			Description: "external or basic type",
		}
	}

	// 5) Store the built schema and externalKnownTypes under lock
	sg.mutex.Lock()
	sg.schemas[typeName] = built
	if sg.typeIndex != nil && sg.typeIndex.externalKnownTypes != nil {
		sg.typeIndex.externalKnownTypes[typeName] = &Schema{
			Ref: fmt.Sprintf("#/components/schemas/%s", typeName),
		}
	}
	sg.mutex.Unlock()

	// 6) Always return a $ref
	return &Schema{Ref: fmt.Sprintf("#/components/schemas/%s", typeName)}
}

func (sg *SchemaGenerator) GenerateSchemaOld(typeName string) *Schema {
	slog.Debug("[openapi] GenerateSchema: called", "typeName", typeName)

	sg.mutex.Lock()
	// Check if already generated
	if _, exists := sg.schemas[typeName]; exists {
		slog.Debug("[openapi] GenerateSchema: schema already exists", "typeName", typeName)
		return &Schema{Ref: fmt.Sprintf("#/components/schemas/%s", typeName)}
	}
	// Reserve a placeholder so recursive calls wonâ€™t re-enter here.
	sg.schemas[typeName] = nil
	sg.mutex.Unlock()

	if typeName == "" || typeName == "<autogenerated>" {
		slog.Debug("[openapi] GenerateSchema: empty typeName, returning object schema")
		return &Schema{Type: "object"}
	}

	// Check typeIndex.externalKnownTypes registry (parsed or external)
	if sg.typeIndex != nil {
		if schema, ok := sg.typeIndex.externalKnownTypes[typeName]; ok {
			slog.Debug("[openapi] GenerateSchema: using typeIndex.externalKnownTypes registry", "typeName", typeName)
			return schema
		}
	}

	// If TypeIndex is present, use it for fast lookup
	if sg.typeIndex != nil {
		parts := strings.Split(typeName, ".")
		if len(parts) == 2 {
			pkg, typ := parts[0], parts[1]
			slog.Debug("[openapi] GenerateSchema: using typeIndex", "pkg", pkg, "typ", typ)

			if ts := sg.typeIndex.LookupType(pkg, typ); ts != nil {
				if structType, ok := ts.Type.(*ast.StructType); ok {
					slog.Debug("[openapi] GenerateSchema: found struct in TypeIndex", "typeName", typeName)
					schema := sg.convertStructToSchema(structType)
					sg.schemas[typeName] = schema
					if sg.typeIndex != nil {
						sg.typeIndex.externalKnownTypes[typeName] = &Schema{
							Ref: fmt.Sprintf("#/components/schemas/%s", typeName),
						}
					}
					return &Schema{Ref: fmt.Sprintf("#/components/schemas/%s", typeName)}
				}
			}
		}
	}

	slog.Debug("[openapi] GenerateSchema: falling back to findAndParseType", "typeName", typeName)
	// Fallback to old method
	schema := sg.findAndParseType(typeName)
	if schema != nil {
		slog.Debug("[openapi] GenerateSchema: found schema via findAndParseType", "typeName", typeName)
		sg.schemas[typeName] = schema
		if sg.typeIndex != nil {
			sg.typeIndex.externalKnownTypes[typeName] = &Schema{Ref: fmt.Sprintf("#/components/schemas/%s", typeName)}
		}
		return &Schema{Ref: fmt.Sprintf("#/components/schemas/%s", typeName)}
	}

	slog.Debug("[openapi] GenerateSchema: using basic type mapping (external or not found)", "typeName", typeName)
	// Mark as external/not found so we don't try again
	basicSchema := &Schema{
		Type:        mapGoTypeToOpenAPI(typeName),
		Description: "external or not found",
	}
	if sg.typeIndex != nil {
		sg.typeIndex.externalKnownTypes[typeName] = basicSchema
	}
	return basicSchema
}

// GetSchemas returns all generated schemas
func (sg *SchemaGenerator) GetSchemas() map[string]Schema {
	slog.Debug("[openapi] GetSchemas: returning all generated schemas", "count", len(sg.schemas))
	result := make(map[string]Schema)
	for name, schema := range sg.schemas {
		result[name] = *schema
	}
	return result
}

// findAndParseType is deprecated - TypeIndex should handle all lookups efficiently
// This method is kept for compatibility but should rarely be used
func (sg *SchemaGenerator) findAndParseType(typeName string) *Schema {
	slog.Debug(
		"[openapi] findAndParseType: DEPRECATED - this should not be called with TypeIndex",
		"typeName",
		typeName,
	)
	// Return nil to force fallback to basic type mapping
	return nil
}

// searchLocalType is deprecated - use TypeIndex instead
func (sg *SchemaGenerator) searchLocalType(typeName string) *Schema {
	slog.Debug("[openapi] searchLocalType: DEPRECATED - use TypeIndex instead", "typeName", typeName)
	return nil
}

// searchInPackage is deprecated - use TypeIndex instead
func (sg *SchemaGenerator) searchInPackage(packageName, structName string) *Schema {
	slog.Debug(
		"[openapi] searchInPackage: DEPRECATED - use TypeIndex instead",
		"packageName",
		packageName,
		"structName",
		structName,
	)
	return nil
}

// searchInDirectory searches for a type definition in a directory
func (sg *SchemaGenerator) searchInDirectory(dir, typeName string) *Schema {
	slog.Debug("[openapi] searchInDirectory: called", "dir", dir, "typeName", typeName)
	files, err := filepath.Glob(filepath.Join(dir, "*.go"))
	if err != nil {
		slog.Debug("[openapi] searchInDirectory: glob error", "err", err)
		return nil
	}

	for _, file := range files {
		slog.Debug("[openapi] searchInDirectory: parsing file", "file", file)
		if schema := sg.parseTypeFromFile(file, typeName); schema != nil {
			slog.Debug("[openapi] searchInDirectory: found schema in file", "file", file)
			return schema
		}
	}

	// Search subdirectories
	dirs, err := filepath.Glob(filepath.Join(dir, "*"))
	if err != nil {
		slog.Debug("[openapi] searchInDirectory: subdir glob error", "err", err)
		return nil
	}

	for _, subdir := range dirs {
		if info, statErr := os.Stat(subdir); statErr == nil && info.IsDir() {
			// Skip hidden directories (e.g., .git, .vscode)
			if strings.HasPrefix(info.Name(), ".") {
				slog.Debug("[openapi] searchInDirectory: skipping hidden dir", "subdir", subdir)
				continue
			}
			slog.Debug("[openapi] searchInDirectory: recursing into subdir", "subdir", subdir)
			if schema := sg.searchInDirectory(subdir, typeName); schema != nil {
				return schema
			}
		}
	}

	return nil
}

// parseTypeFromFile parses a Go file to find a specific type definition
func (sg *SchemaGenerator) parseTypeFromFile(filePath, typeName string) *Schema {
	slog.Debug("[openapi] parseTypeFromFile: called", "filePath", filePath, "typeName", typeName)
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filePath, nil, parser.ParseComments)
	if err != nil {
		slog.Debug("[openapi] parseTypeFromFile: parse error", "err", err)
		return nil
	}

	for _, decl := range node.Decls {
		if genDecl, ok := decl.(*ast.GenDecl); ok && genDecl.Tok == token.TYPE {
			for _, spec := range genDecl.Specs {
				if typeSpec, isTypeSpec := spec.(*ast.TypeSpec); isTypeSpec && typeSpec.Name.Name == typeName {
					if structType, isStructType := typeSpec.Type.(*ast.StructType); isStructType {
						slog.Debug("[openapi] parseTypeFromFile: found struct type", "typeName", typeName)
						return sg.convertStructToSchema(structType)
					}
				}
			}
		}
	}

	return nil
}

// convertStructToSchema converts an AST struct to OpenAPI schema
func (sg *SchemaGenerator) convertStructToSchema(structType *ast.StructType) *Schema {
	slog.Debug("[openapi] convertStructToSchema: called")
	schema := &Schema{
		Type:       "object",
		Properties: make(map[string]*Schema),
		Required:   []string{},
	}

	for _, field := range structType.Fields.List {
		if len(field.Names) == 0 {
			continue // embedded field
		}

		fieldName := field.Names[0].Name
		if !ast.IsExported(fieldName) {
			continue // skip unexported fields
		}

		// Extract JSON tag
		jsonName := fieldName
		if field.Tag != nil {
			tag := strings.Trim(field.Tag.Value, "`")
			if jsonTag := extractJSONTag(tag); jsonTag != "" && jsonTag != "-" {
				jsonName = jsonTag
			}
		}

		// Convert field type to schema
		fieldSchema := sg.convertFieldType(field.Type)
		schema.Properties[jsonName] = fieldSchema

		// Ensure referenced types are generated (this ensures nested schemas are added to components)
		switch t := field.Type.(type) {
		case *ast.Ident:
			if t.Obj != nil && t.Obj.Kind == ast.Typ {
				// Likely a struct type in the same file/package
				_ = sg.GenerateSchema(t.Name)
			}
		case *ast.StarExpr:
			if ident, ok := t.X.(*ast.Ident); ok {
				if ident.Obj != nil && ident.Obj.Kind == ast.Typ {
					_ = sg.GenerateSchema(ident.Name)
				}
			}
		case *ast.SelectorExpr:
			if ident, ok := t.X.(*ast.Ident); ok {
				_ = sg.GenerateSchema(ident.Name + "." + t.Sel.Name)
			}
		}

		// Check if required (simple heuristic: no pointer, no omitempty)
		if !isPointerType(field.Type) && !hasOmitEmpty(field.Tag) {
			schema.Required = append(schema.Required, jsonName)
		}
	}

	return schema
}

// convertFieldType converts an AST type to OpenAPI schema
func (sg *SchemaGenerator) convertFieldType(expr ast.Expr) *Schema {
	slog.Debug("[openapi] convertFieldType: called")
	switch t := expr.(type) {
	case *ast.Ident:
		slog.Debug("[openapi] convertFieldType: Ident type", "name", t.Name)
		// Check if it's a basic type first
		basicType := mapGoTypeToOpenAPI(t.Name)
		if basicType != "object" {
			return &Schema{Type: basicType}
		}
		// For custom types, always try to generate schema (even if t.Obj is nil)
		// This handles types from other packages better
		return sg.GenerateSchema(t.Name)
	case *ast.StarExpr:
		slog.Debug("[openapi] convertFieldType: StarExpr (pointer) type")
		return sg.convertFieldType(t.X)
	case *ast.ArrayType:
		slog.Debug("[openapi] convertFieldType: ArrayType")
		return &Schema{
			Type:  "array",
			Items: sg.convertFieldType(t.Elt),
		}
	case *ast.SelectorExpr:
		slog.Debug("[openapi] convertFieldType: SelectorExpr", "sel", t.Sel.Name)
		// Handle qualified types like json.RawMessage, time.Time, etc.
		if ident, ok := t.X.(*ast.Ident); ok {
			typeName := ident.Name + "." + t.Sel.Name
			slog.Debug("[openapi] convertFieldType: generating schema for qualified type", "typeName", typeName)
			return sg.GenerateSchema(typeName)
		}
	case *ast.MapType:
		slog.Debug("[openapi] convertFieldType: MapType")
		return &Schema{Type: "object", AdditionalProperties: sg.convertFieldType(t.Value)}
	case *ast.InterfaceType:
		slog.Debug("[openapi] convertFieldType: InterfaceType")
		return &Schema{Type: "object"}
	}

	slog.Debug("[openapi] convertFieldType: unknown type, defaulting to object")
	return &Schema{Type: "object"}
}

// Helper functions
func extractJSONTag(tag string) string {
	for _, part := range strings.Split(tag, " ") {
		if strings.HasPrefix(part, "json:") {
			value := strings.Trim(part[5:], "\"")
			if comma := strings.Index(value, ","); comma != -1 {
				return value[:comma]
			}
			return value
		}
	}
	return ""
}

func isPointerType(expr ast.Expr) bool {
	_, ok := expr.(*ast.StarExpr)
	return ok
}

func hasOmitEmpty(tag *ast.BasicLit) bool {
	if tag == nil {
		return false
	}
	return strings.Contains(tag.Value, "omitempty")
}

// isBasicType returns true if the given type name represents a basic Go type
func isBasicType(typeName string) bool {
	switch typeName {
	case "int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64",
		"float32", "float64",
		"string", "bool",
		"byte", "rune":
		return true
	default:
		// Array types are also considered basic for OpenAPI purposes
		if strings.HasPrefix(typeName, "[]") {
			return true
		}
		// Pointer types to basic types
		if strings.HasPrefix(typeName, "*") && isBasicType(strings.TrimPrefix(typeName, "*")) {
			return true
		}
		// Map types
		if strings.HasPrefix(typeName, "map[") {
			return true
		}
		return false
	}
}

// findPackageDirectories dynamically discovers directories containing the specified package
func (sg *SchemaGenerator) findPackageDirectories(packageName string) []string {
	var packageDirs []string

	dirs := sg.findDirectoriesWithPackage(".", packageName)
	packageDirs = append(packageDirs, dirs...)

	return packageDirs
}

// findDirectoriesWithPackage recursively searches for directories containing files with the given package name
func (sg *SchemaGenerator) findDirectoriesWithPackage(dir, packageName string) []string {
	var foundDirs []string

	// Check if this directory has files with the target package
	files, err := filepath.Glob(filepath.Join(dir, "*.go"))
	if err == nil {
		for _, file := range files {
			if sg.fileHasPackage(file, packageName) {
				foundDirs = append(foundDirs, dir)
				break
			}
		}
	}

	// Search subdirectories
	subdirs, err := filepath.Glob(filepath.Join(dir, "*"))
	if err == nil {
		for _, subdir := range subdirs {
			if info, statErr := os.Stat(subdir); statErr == nil && info.IsDir() {
				subResults := sg.findDirectoriesWithPackage(subdir, packageName)
				foundDirs = append(foundDirs, subResults...)
			}
		}
	}

	return foundDirs
}

// fileHasPackage checks if a Go file declares the specified package
func (sg *SchemaGenerator) fileHasPackage(filePath, packageName string) bool {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filePath, nil, parser.PackageClauseOnly)
	if err != nil {
		return false
	}

	return node.Name.Name == packageName
}

// searchInDirectoryForPackage searches for a type in directories that contain the specified package
func (sg *SchemaGenerator) searchInDirectoryForPackage(rootDir, packageName, typeName string) *Schema {
	packageDirs := sg.findDirectoriesWithPackage(rootDir, packageName)

	for _, dir := range packageDirs {
		if schema := sg.searchInDirectory(dir, typeName); schema != nil {
			return schema
		}
	}

	return nil
}

// generateBasicTypeSchema creates a schema for basic Go types without caching
func (sg *SchemaGenerator) generateBasicTypeSchema(typeName string) *Schema {
	if strings.HasPrefix(typeName, "[]") {
		// Array type - extract element type
		elementType := strings.TrimPrefix(typeName, "[]")
		elementSchema := sg.GenerateSchema(elementType)
		return &Schema{
			Type:  "array",
			Items: elementSchema,
		}
	}
	if strings.HasPrefix(typeName, "*") {
		// Pointer type - return the underlying type
		underlyingType := strings.TrimPrefix(typeName, "*")
		return sg.GenerateSchema(underlyingType)
	}
	if strings.HasPrefix(typeName, "map[") {
		// Map type - return object schema
		return &Schema{
			Type:                 "object",
			AdditionalProperties: true,
		}
	}

	// Basic primitive types
	basicType := mapGoTypeToOpenAPI(typeName)
	return &Schema{
		Type:        basicType,
		Description: "basic Go type",
	}
}
