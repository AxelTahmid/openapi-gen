package openapi

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log/slog"
	"strconv"
	"strings"
	"sync"
)

// Annotation represents parsed swagger annotations
type Annotation struct {
	Summary     string
	Description string
	Tags        []string
	Accept      []string
	Produce     []string
	Security    []string
	Parameters  []ParamAnnotation
	Success     *SuccessResponse
	Failures    []ErrorResponse
}

type SuccessResponse struct {
	StatusCode  int
	DataType    string
	Description string
}

type ParamAnnotation struct {
	Name        string
	In          string
	Type        string
	Required    bool
	Description string
}

type ErrorResponse struct {
	StatusCode  int
	Type        string
	Description string
}

var astCache = make(map[string]*ast.File)
var astCacheMutex sync.RWMutex

// AnnotationParsingError represents errors encountered while parsing annotation lines.
// It contains one or more error messages for malformed annotation directives.
type AnnotationParsingError struct {
	Messages []string
}

func (e *AnnotationParsingError) Error() string {
	return "annotation parsing errors: " + strings.Join(e.Messages, "; ")
}

// ParseAnnotations extracts OpenAPI annotations from Go source comments for a given function.
// It returns an Annotation struct and an error if any annotation lines were malformed.
func ParseAnnotations(filePath, functionName string) (*Annotation, error) {
	slog.Debug("[openapi] ParseAnnotations: called", "filePath", filePath, "functionName", functionName)
	if filePath == "" || filePath == "<autogenerated>" ||
		strings.Contains(filePath, "/go/pkg/mod/") ||
		!strings.HasSuffix(filePath, ".go") {
		slog.Debug("[openapi] ParseAnnotations: skipping file", "filePath", filePath)
		return nil, nil
	}

	// First try to get the file from the global TypeIndex
	var astFile *ast.File
	if typeIndex != nil {
		if file, exists := typeIndex.files[filePath]; exists {
			slog.Debug("[openapi] ParseAnnotations: using TypeIndex cached file", "filePath", filePath)
			astFile = file
		}
	}

	// Fallback to our own cache if not in TypeIndex
	if astFile == nil {
		astCacheMutex.RLock()
		file, exists := astCache[filePath]
		astCacheMutex.RUnlock()

		if exists {
			slog.Debug("[openapi] ParseAnnotations: astCache hit", "filePath", filePath)
			astFile = file
		} else {
			slog.Debug("[openapi] ParseAnnotations: parsing file (cache miss)", "filePath", filePath)
			fset := token.NewFileSet()
			parsedFile, err := parser.ParseFile(fset, filePath, nil, parser.ParseComments)
			if err != nil {
				slog.Debug("[openapi] ParseAnnotations: failed to parse file", "err", err)
				return nil, err
			}

			astCacheMutex.Lock()
			astCache[filePath] = parsedFile
			astFile = parsedFile
			astCacheMutex.Unlock()
		}
	}

	// Find the function and its comment
	var comment string
	for _, decl := range astFile.Decls {
		if funcDecl, ok := decl.(*ast.FuncDecl); ok {
			if funcDecl.Name.Name == functionName && funcDecl.Doc != nil {
				slog.Debug("[openapi] ParseAnnotations: found function with doc", "functionName", functionName)
				comment = funcDecl.Doc.Text()
				break
			}
		}
	}

	if comment == "" {
		slog.Debug("[openapi] ParseAnnotations: no comment found", "functionName", functionName)
		return nil, nil
	}

	slog.Debug("[openapi] ParseAnnotations: parsing annotation comment")
	annotation, err := parseAnnotationComment(comment)
	if err != nil {
		slog.Warn("[openapi] ParseAnnotations: parsing errors", "error", err)
	}
	return annotation, nil
}

// parseAnnotationComment parses both legacy and OpenAPI 3.1 annotations and reports malformed lines.
func parseAnnotationComment(comment string) (*Annotation, error) {
	var errs []string
	annotation := &Annotation{}
	lines := strings.Split(comment, "\n")

	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line == "" {
			continue
		}

		switch {
		case strings.HasPrefix(line, "@Summary "):
			annotation.Summary = strings.TrimPrefix(line, "@Summary ")
		case strings.HasPrefix(line, "@Description "):
			annotation.Description = strings.TrimPrefix(line, "@Description ")
		case strings.HasPrefix(line, "@Tags "):
			tags := strings.TrimPrefix(line, "@Tags ")
			annotation.Tags = strings.Split(tags, ",")
			for i := range annotation.Tags {
				annotation.Tags[i] = strings.TrimSpace(annotation.Tags[i])
			}

		case strings.HasPrefix(line, "@Accept"):
			accept := strings.TrimSpace(strings.TrimPrefix(line, "@Accept"))
			if accept == "" {
				accept = "application/json"
			}
			annotation.Accept = append(annotation.Accept, accept)

		case strings.HasPrefix(line, "@Produce"):
			produce := strings.TrimSpace(strings.TrimPrefix(line, "@Produce"))
			if produce == "" {
				produce = "application/json"
			}
			annotation.Produce = append(annotation.Produce, produce)

		case strings.HasPrefix(line, "@Security"):
			security := strings.TrimSpace(strings.TrimPrefix(line, "@Security"))
			annotation.Security = append(annotation.Security, security)

		case strings.HasPrefix(line, "@Param "):
			param, err := parseParamAnnotation(line)
			if err != nil {
				errs = append(errs, err.Error())
			} else {
				annotation.Parameters = append(annotation.Parameters, *param)
			}

		case strings.HasPrefix(line, "@Success "):
			succ, err := parseSuccessAnnotation(line)
			if err != nil {
				errs = append(errs, err.Error())
			} else {
				annotation.Success = succ
			}

		case strings.HasPrefix(line, "@Failure "):
			fail, err := parseFailureAnnotation(line)
			if err != nil {
				errs = append(errs, err.Error())
			} else {
				annotation.Failures = append(annotation.Failures, *fail)
			}
		}
	}

	if len(errs) > 0 {
		return annotation, &AnnotationParsingError{Messages: errs}
	}
	return annotation, nil
}

// parseSuccessAnnotation parses an @Success line into SuccessResponse or returns an error.
func parseSuccessAnnotation(line string) (*SuccessResponse, error) {
	slog.Debug("[openapi] parseSuccessAnnotation: called", "line", line)
	// @Success 200 {data} Type "Description"
	content := strings.TrimPrefix(line, "@Success ")
	parts := strings.Fields(content)
	if len(parts) < 2 {
		return nil, fmt.Errorf("invalid @Success annotation: %s", line)
	}

	statusCode, err := strconv.Atoi(parts[0])
	if err != nil {
		return nil, err
	}

	response := &SuccessResponse{StatusCode: statusCode}
	remaining := strings.Join(parts[1:], " ")

	// Extract type from {data} Type or {object} Type
	if strings.Contains(remaining, "{data}") || strings.Contains(remaining, "{object}") {
		remaining = strings.Replace(remaining, "{data}", "", 1)
		remaining = strings.Replace(remaining, "{object}", "", 1)
		remaining = strings.TrimSpace(remaining)

		parts := strings.Fields(remaining)
		if len(parts) > 0 {
			response.DataType = parts[0]
		}
	}

	// Extract description from quotes
	if start := strings.Index(remaining, "\""); start != -1 {
		if end := strings.LastIndex(remaining, "\""); end != -1 && end > start {
			response.Description = remaining[start+1 : end]
		}
	}

	return response, nil
}

func parseParamAnnotation(line string) (*ParamAnnotation, error) {
	slog.Debug("[openapi] parseParamAnnotation: called", "line", line)
	// @Param name in type required "description"
	content := strings.TrimPrefix(line, "@Param ")
	parts := strings.Fields(content)
	if len(parts) < 4 {
		return nil, fmt.Errorf("invalid @Param annotation: %s", line)
	}

	param := &ParamAnnotation{
		Name:     parts[0],
		In:       parts[1],
		Type:     parts[2],
		Required: parts[3] == "true",
	}

	// Extract description
	if start := strings.Index(content, "\""); start != -1 {
		if end := strings.LastIndex(content, "\""); end != -1 && end > start {
			param.Description = content[start+1 : end]
		}
	}

	return param, nil
}

func parseFailureAnnotation(line string) (*ErrorResponse, error) {
	slog.Debug("[openapi] parseFailureAnnotation: called", "line", line)
	// @Failure 400 {object} Type "Description"
	content := strings.TrimPrefix(line, "@Failure ")
	parts := strings.Fields(content)
	if len(parts) < 2 {
		return nil, fmt.Errorf("invalid @Failure annotation: %s", line)
	}

	statusCode, err := strconv.Atoi(parts[0])
	if err != nil {
		return nil, err
	}

	failure := &ErrorResponse{StatusCode: statusCode}

	// Extract description
	if start := strings.Index(content, "\""); start != -1 {
		if end := strings.LastIndex(content, "\""); end != -1 && end > start {
			failure.Description = content[start+1 : end]
		}
	}

	return failure, nil
}
