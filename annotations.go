package openapi

import (
	"go/ast"
	"go/parser"
	"go/token"
	"log/slog"
	"strconv"
	"strings"
	"sync"
)

// Annotation represents parsed swagger annotations
type Annotation struct {
	Summary     string
	Description string
	Tags        []string
	Accept      []string
	Produce     []string
	Security    []string
	Parameters  []ParamAnnotation
	Success     *SuccessResponse
	Failures    []ErrorResponse
}

type SuccessResponse struct {
	StatusCode  int
	DataType    string
	Description string
}

type ParamAnnotation struct {
	Name        string
	In          string
	Type        string
	Required    bool
	Description string
}

type ErrorResponse struct {
	StatusCode  int
	Type        string
	Description string
}

var astCache = make(map[string]*ast.File)
var astCacheMutex sync.RWMutex

// ParseAnnotations extracts swagger annotations from Go source comments
func ParseAnnotations(filePath, functionName string) *Annotation {
	slog.Debug("[openapi] ParseAnnotations: called", "filePath", filePath, "functionName", functionName)
	if filePath == "" || filePath == "<autogenerated>" ||
		strings.Contains(filePath, "/go/pkg/mod/") ||
		!strings.HasSuffix(filePath, ".go") {
		slog.Debug("[openapi] ParseAnnotations: skipping file", "filePath", filePath)
		return nil
	}

	// First try to get the file from the global TypeIndex
	var astFile *ast.File
	if typeIndex != nil {
		if file, exists := typeIndex.files[filePath]; exists {
			slog.Debug("[openapi] ParseAnnotations: using TypeIndex cached file", "filePath", filePath)
			astFile = file
		}
	}

	// Fallback to our own cache if not in TypeIndex
	if astFile == nil {
		astCacheMutex.RLock()
		file, exists := astCache[filePath]
		astCacheMutex.RUnlock()

		if exists {
			slog.Debug("[openapi] ParseAnnotations: astCache hit", "filePath", filePath)
			astFile = file
		} else {
			slog.Debug("[openapi] ParseAnnotations: parsing file (cache miss)", "filePath", filePath)
			fset := token.NewFileSet()
			parsedFile, err := parser.ParseFile(fset, filePath, nil, parser.ParseComments)
			if err != nil {
				slog.Debug("[openapi] ParseAnnotations: failed to parse file", "err", err)
				return nil
			}

			astCacheMutex.Lock()
			astCache[filePath] = parsedFile
			astFile = parsedFile
			astCacheMutex.Unlock()
		}
	}

	// Find the function and its comment
	var comment string
	for _, decl := range astFile.Decls {
		if funcDecl, ok := decl.(*ast.FuncDecl); ok {
			if funcDecl.Name.Name == functionName && funcDecl.Doc != nil {
				slog.Debug("[openapi] ParseAnnotations: found function with doc", "functionName", functionName)
				comment = funcDecl.Doc.Text()
				break
			}
		}
	}

	if comment == "" {
		slog.Debug("[openapi] ParseAnnotations: no comment found", "functionName", functionName)
		return nil
	}

	slog.Debug("[openapi] ParseAnnotations: parsing annotation comment")
	annotation := parseAnnotationComment(comment)

	// Enhanced annotation parsing for OpenAPI 3.1 features
	if annotation == nil {
		annotation = parseOpenAPI31Annotations(comment)
	}

	return annotation
}

func parseAnnotationComment(comment string) *Annotation {
	slog.Debug("[openapi] parseAnnotationComment: called")
	annotation := &Annotation{}
	lines := strings.Split(comment, "\n")

	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line == "" {
			continue
		}

		switch {
		case strings.HasPrefix(line, "@Summary"):
			annotation.Summary = strings.TrimSpace(strings.TrimPrefix(line, "@Summary"))

		case strings.HasPrefix(line, "@Description"):
			annotation.Description = strings.TrimSpace(strings.TrimPrefix(line, "@Description"))

		case strings.HasPrefix(line, "@Tags"):
			tags := strings.TrimSpace(strings.TrimPrefix(line, "@Tags"))
			annotation.Tags = strings.Split(tags, ",")
			for i := range annotation.Tags {
				annotation.Tags[i] = strings.TrimSpace(annotation.Tags[i])
			}

		case strings.HasPrefix(line, "@Accept"):
			accept := strings.TrimSpace(strings.TrimPrefix(line, "@Accept"))
			if accept == "" {
				accept = "application/json"
			}
			annotation.Accept = append(annotation.Accept, accept)

		case strings.HasPrefix(line, "@Produce"):
			produce := strings.TrimSpace(strings.TrimPrefix(line, "@Produce"))
			if produce == "" {
				produce = "application/json"
			}
			annotation.Produce = append(annotation.Produce, produce)

		case strings.HasPrefix(line, "@Security"):
			security := strings.TrimSpace(strings.TrimPrefix(line, "@Security"))
			annotation.Security = append(annotation.Security, security)

		case strings.HasPrefix(line, "@Param"):
			param := parseParamAnnotation(line)
			if param != nil {
				annotation.Parameters = append(annotation.Parameters, *param)
			}

		case strings.HasPrefix(line, "@Success"):
			annotation.Success = parseSuccessAnnotation(line)

		case strings.HasPrefix(line, "@Failure"):
			failure := parseFailureAnnotation(line)
			if failure != nil {
				annotation.Failures = append(annotation.Failures, *failure)
			}
		}
	}

	return annotation
}

func parseSuccessAnnotation(line string) *SuccessResponse {
	slog.Debug("[openapi] parseSuccessAnnotation: called", "line", line)
	// @Success 200 {data} Type "Description"
	content := strings.TrimPrefix(line, "@Success ")
	parts := strings.Fields(content)
	if len(parts) < 2 {
		return nil
	}

	statusCode, err := strconv.Atoi(parts[0])
	if err != nil {
		return nil
	}

	response := &SuccessResponse{StatusCode: statusCode}
	remaining := strings.Join(parts[1:], " ")

	// Extract type from {data} Type or {object} Type
	if strings.Contains(remaining, "{data}") || strings.Contains(remaining, "{object}") {
		remaining = strings.Replace(remaining, "{data}", "", 1)
		remaining = strings.Replace(remaining, "{object}", "", 1)
		remaining = strings.TrimSpace(remaining)

		parts := strings.Fields(remaining)
		if len(parts) > 0 {
			response.DataType = parts[0]
		}
	}

	// Extract description from quotes
	if start := strings.Index(remaining, "\""); start != -1 {
		if end := strings.LastIndex(remaining, "\""); end != -1 && end > start {
			response.Description = remaining[start+1 : end]
		}
	}

	return response
}

func parseParamAnnotation(line string) *ParamAnnotation {
	slog.Debug("[openapi] parseParamAnnotation: called", "line", line)
	// @Param name in type required "description"
	content := strings.TrimPrefix(line, "@Param ")
	parts := strings.Fields(content)
	if len(parts) < 4 {
		return nil
	}

	param := &ParamAnnotation{
		Name:     parts[0],
		In:       parts[1],
		Type:     parts[2],
		Required: parts[3] == "true",
	}

	// Extract description
	if start := strings.Index(content, "\""); start != -1 {
		if end := strings.LastIndex(content, "\""); end != -1 && end > start {
			param.Description = content[start+1 : end]
		}
	}

	return param
}

func parseFailureAnnotation(line string) *ErrorResponse {
	slog.Debug("[openapi] parseFailureAnnotation: called", "line", line)
	// @Failure 400 {object} Type "Description"
	content := strings.TrimPrefix(line, "@Failure ")
	parts := strings.Fields(content)
	if len(parts) < 2 {
		return nil
	}

	statusCode, err := strconv.Atoi(parts[0])
	if err != nil {
		return nil
	}

	failure := &ErrorResponse{StatusCode: statusCode}

	// Extract description
	if start := strings.Index(content, "\""); start != -1 {
		if end := strings.LastIndex(content, "\""); end != -1 && end > start {
			failure.Description = content[start+1 : end]
		}
	}

	return failure
}

func mapGoTypeToOpenAPI(goType string) string {
	slog.Debug("[openapi] mapGoTypeToOpenAPI: called", "goType", goType)
	switch goType {
	case "int", "int8", "int16", "int32", "int64":
		return "integer"
	case "float32", "float64":
		return "number"
	case "string":
		return "string"
	case "bool":
		return "boolean"
	case "slice":
		return "array"
	default:
		if strings.HasPrefix(goType, "[]") {
			return "array"
		}
		// Fallback: treat as object
		return "object"
	}
}

// Enhanced annotation parsing for OpenAPI 3.1 features

// parseOpenAPI31Annotations parses enhanced OpenAPI 3.1 annotations
func parseOpenAPI31Annotations(comment string) *Annotation {
	if comment == "" {
		return nil
	}

	annotation := &Annotation{
		Parameters: []ParamAnnotation{},
		Failures:   []ErrorResponse{},
	}

	lines := strings.Split(comment, "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line == "" || !strings.HasPrefix(line, "@") {
			continue
		}

		parts := strings.Fields(line)
		if len(parts) < 2 {
			continue
		}

		tag := parts[0]
		switch tag {
		case "@Summary":
			annotation.Summary = strings.Join(parts[1:], " ")
		case "@Description":
			annotation.Description = strings.Join(parts[1:], " ")
		case "@Tags":
			annotation.Tags = parts[1:]
		case "@Accept":
			annotation.Accept = parts[1:]
		case "@Produce":
			annotation.Produce = parts[1:]
		case "@Security":
			annotation.Security = parts[1:]
		case "@Param":
			if param := parseParameter(parts[1:]); param != nil {
				annotation.Parameters = append(annotation.Parameters, *param)
			}
		case "@Success":
			if success := parseSuccess(parts[1:]); success != nil {
				annotation.Success = success
			}
		case "@Failure", "@Error":
			if failure := parseFailure(parts[1:]); failure != nil {
				annotation.Failures = append(annotation.Failures, *failure)
			}
		case "@Header":
			// Enhanced: Parse response headers
			// @Header X-Request-ID string "Request ID"
		case "@Example":
			// Enhanced: Parse examples
			// @Example request {"name": "John", "email": "john@example.com"}
		case "@Deprecated":
			// Enhanced: Mark as deprecated
		}
	}

	return annotation
}

// parseParameter parses enhanced parameter annotations
func parseParameter(parts []string) *ParamAnnotation {
	if len(parts) < 4 {
		return nil
	}

	param := &ParamAnnotation{
		Name: parts[0],
		In:   parts[1],
		Type: parts[2],
	}

	// Parse additional attributes
	for i := 3; i < len(parts); i++ {
		part := parts[i]
		if part == "true" && i == 3 {
			param.Required = true
		} else if strings.HasPrefix(part, "\"") {
			// Description
			desc := strings.Join(parts[i:], " ")
			param.Description = strings.Trim(desc, "\"")
			break
		}
	}

	return param
}

// parseSuccess parses success response annotations
func parseSuccess(parts []string) *SuccessResponse {
	if len(parts) < 3 {
		return nil
	}

	statusCode, err := strconv.Atoi(parts[0])
	if err != nil {
		return nil
	}

	dataType := parts[1]
	if strings.HasPrefix(dataType, "{") && strings.HasSuffix(dataType, "}") {
		dataType = strings.Trim(dataType, "{}")
	}

	description := "Success"
	if len(parts) > 2 {
		desc := strings.Join(parts[2:], " ")
		description = strings.Trim(desc, "\"")
	}

	return &SuccessResponse{
		StatusCode:  statusCode,
		DataType:    dataType,
		Description: description,
	}
}

// parseFailure parses failure response annotations
func parseFailure(parts []string) *ErrorResponse {
	if len(parts) < 2 {
		return nil
	}

	statusCode, err := strconv.Atoi(parts[0])
	if err != nil {
		return nil
	}

	errorType := "ErrorResponse"
	description := "Error response"

	if len(parts) > 1 {
		if strings.HasPrefix(parts[1], "{") && strings.HasSuffix(parts[1], "}") {
			errorType = strings.Trim(parts[1], "{}")
		}

		if len(parts) > 2 {
			desc := strings.Join(parts[2:], " ")
			description = strings.Trim(desc, "\"")
		}
	}

	return &ErrorResponse{
		StatusCode:  statusCode,
		Type:        errorType,
		Description: description,
	}
}
