package openapi

import (
	"go/ast"
	"go/parser"
	"go/token"
	"log/slog"
	"strconv"
	"strings"
	"sync"
)

// Annotation represents parsed swagger annotations
type Annotation struct {
	Summary     string
	Description string
	Tags        []string
	Accept      []string
	Produce     []string
	Security    []string
	Parameters  []ParamAnnotation
	Success     *SuccessResponse
	Failures    []ErrorResponse
}

type SuccessResponse struct {
	StatusCode  int
	DataType    string
	Description string
}

type ParamAnnotation struct {
	Name        string
	In          string
	Type        string
	Required    bool
	Description string
}

type ErrorResponse struct {
	StatusCode  int
	Type        string
	Description string
}

var astCache = make(map[string]*ast.File)
var astCacheMutex sync.RWMutex

// ParseAnnotations extracts swagger annotations from Go source comments
func ParseAnnotations(filePath, functionName string) *Annotation {
	slog.Info("[openapi] ParseAnnotations: called", "filePath", filePath, "functionName", functionName)
	if filePath == "" || filePath == "<autogenerated>" ||
		strings.Contains(filePath, "/go/pkg/mod/") ||
		!strings.HasSuffix(filePath, ".go") {
		slog.Info("[openapi] ParseAnnotations: skipping file", "filePath", filePath)
		return nil
	}

	// First try to get the file from the global TypeIndex
	var astFile *ast.File
	if typeIndex != nil {
		if file, exists := typeIndex.files[filePath]; exists {
			slog.Info("[openapi] ParseAnnotations: using TypeIndex cached file", "filePath", filePath)
			astFile = file
		}
	}

	// Fallback to our own cache if not in TypeIndex
	if astFile == nil {
		astCacheMutex.RLock()
		file, exists := astCache[filePath]
		astCacheMutex.RUnlock()

		if exists {
			slog.Info("[openapi] ParseAnnotations: astCache hit", "filePath", filePath)
			astFile = file
		} else {
			slog.Info("[openapi] ParseAnnotations: parsing file (cache miss)", "filePath", filePath)
			fset := token.NewFileSet()
			parsedFile, err := parser.ParseFile(fset, filePath, nil, parser.ParseComments)
			if err != nil {
				slog.Info("[openapi] ParseAnnotations: failed to parse file", "err", err)
				return nil
			}

			astCacheMutex.Lock()
			astCache[filePath] = parsedFile
			astFile = parsedFile
			astCacheMutex.Unlock()
		}
	}

	// Find the function and its comment
	var comment string
	for _, decl := range astFile.Decls {
		if funcDecl, ok := decl.(*ast.FuncDecl); ok {
			if funcDecl.Name.Name == functionName && funcDecl.Doc != nil {
				slog.Info("[openapi] ParseAnnotations: found function with doc", "functionName", functionName)
				comment = funcDecl.Doc.Text()
				break
			}
		}
	}

	if comment == "" {
		slog.Info("[openapi] ParseAnnotations: no comment found", "functionName", functionName)
		return nil
	}

	slog.Info("[openapi] ParseAnnotations: parsing annotation comment")
	return parseAnnotationComment(comment)
}

func parseAnnotationComment(comment string) *Annotation {
	slog.Info("[openapi] parseAnnotationComment: called")
	annotation := &Annotation{}
	lines := strings.Split(comment, "\n")

	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line == "" {
			continue
		}

		switch {
		case strings.HasPrefix(line, "@Summary"):
			annotation.Summary = strings.TrimSpace(strings.TrimPrefix(line, "@Summary"))

		case strings.HasPrefix(line, "@Description"):
			annotation.Description = strings.TrimSpace(strings.TrimPrefix(line, "@Description"))

		case strings.HasPrefix(line, "@Tags"):
			tags := strings.TrimSpace(strings.TrimPrefix(line, "@Tags"))
			annotation.Tags = strings.Split(tags, ",")
			for i := range annotation.Tags {
				annotation.Tags[i] = strings.TrimSpace(annotation.Tags[i])
			}

		case strings.HasPrefix(line, "@Accept"):
			accept := strings.TrimSpace(strings.TrimPrefix(line, "@Accept"))
			if accept == "" {
				accept = "application/json"
			}
			annotation.Accept = append(annotation.Accept, accept)

		case strings.HasPrefix(line, "@Produce"):
			produce := strings.TrimSpace(strings.TrimPrefix(line, "@Produce"))
			if produce == "" {
				produce = "application/json"
			}
			annotation.Produce = append(annotation.Produce, produce)

		case strings.HasPrefix(line, "@Security"):
			security := strings.TrimSpace(strings.TrimPrefix(line, "@Security"))
			annotation.Security = append(annotation.Security, security)

		case strings.HasPrefix(line, "@Param"):
			param := parseParamAnnotation(line)
			if param != nil {
				annotation.Parameters = append(annotation.Parameters, *param)
			}

		case strings.HasPrefix(line, "@Success"):
			annotation.Success = parseSuccessAnnotation(line)

		case strings.HasPrefix(line, "@Failure"):
			failure := parseFailureAnnotation(line)
			if failure != nil {
				annotation.Failures = append(annotation.Failures, *failure)
			}
		}
	}

	return annotation
}

func parseSuccessAnnotation(line string) *SuccessResponse {
	slog.Info("[openapi] parseSuccessAnnotation: called", "line", line)
	// @Success 200 {data} Type "Description"
	content := strings.TrimPrefix(line, "@Success ")
	parts := strings.Fields(content)
	if len(parts) < 2 {
		return nil
	}

	statusCode, err := strconv.Atoi(parts[0])
	if err != nil {
		return nil
	}

	response := &SuccessResponse{StatusCode: statusCode}
	remaining := strings.Join(parts[1:], " ")

	// Extract type from {data} Type or {object} Type
	if strings.Contains(remaining, "{data}") || strings.Contains(remaining, "{object}") {
		remaining = strings.Replace(remaining, "{data}", "", 1)
		remaining = strings.Replace(remaining, "{object}", "", 1)
		remaining = strings.TrimSpace(remaining)

		parts := strings.Fields(remaining)
		if len(parts) > 0 {
			response.DataType = parts[0]
		}
	}

	// Extract description from quotes
	if start := strings.Index(remaining, "\""); start != -1 {
		if end := strings.LastIndex(remaining, "\""); end != -1 && end > start {
			response.Description = remaining[start+1 : end]
		}
	}

	return response
}

func parseParamAnnotation(line string) *ParamAnnotation {
	slog.Info("[openapi] parseParamAnnotation: called", "line", line)
	// @Param name in type required "description"
	content := strings.TrimPrefix(line, "@Param ")
	parts := strings.Fields(content)
	if len(parts) < 4 {
		return nil
	}

	param := &ParamAnnotation{
		Name:     parts[0],
		In:       parts[1],
		Type:     parts[2],
		Required: parts[3] == "true",
	}

	// Extract description
	if start := strings.Index(content, "\""); start != -1 {
		if end := strings.LastIndex(content, "\""); end != -1 && end > start {
			param.Description = content[start+1 : end]
		}
	}

	return param
}

func parseFailureAnnotation(line string) *ErrorResponse {
	slog.Info("[openapi] parseFailureAnnotation: called", "line", line)
	// @Failure 400 {object} Type "Description"
	content := strings.TrimPrefix(line, "@Failure ")
	parts := strings.Fields(content)
	if len(parts) < 2 {
		return nil
	}

	statusCode, err := strconv.Atoi(parts[0])
	if err != nil {
		return nil
	}

	failure := &ErrorResponse{StatusCode: statusCode}

	// Extract description
	if start := strings.Index(content, "\""); start != -1 {
		if end := strings.LastIndex(content, "\""); end != -1 && end > start {
			failure.Description = content[start+1 : end]
		}
	}

	return failure
}

func mapGoTypeToOpenAPI(goType string) string {
	slog.Info("[openapi] mapGoTypeToOpenAPI: called", "goType", goType)
	switch goType {
	case "int", "int8", "int16", "int32", "int64":
		return "integer"
	case "float32", "float64":
		return "number"
	case "string":
		return "string"
	case "bool":
		return "boolean"
	case "slice":
		return "array"
	default:
		if strings.HasPrefix(goType, "[]") {
			return "array"
		}
		// Fallback: treat as object
		return "object"
	}
}
